#!/bin/bash
set -euo pipefail



# initilize global variables
# ==========================

# target - a path to the disk or file
dev=

# path to the xx set of the programs to be installed
xx_set=

# path and dir name with the system config, dir name is also a hostname
cfg_dir=
cfg_name=

# default suffix of the kernel in /boot
kernel=generic

# space separated list of services to start during boot
services='sshd'

# encrypt the root partition
encrypt=false

# use initramfs during boot
initramfs=false

# set LXC_NET in rc.conf to create bridge interface for lxc containers
lxc_net=false

# add files for uefi
uefi=false

# setup serial connection in inittab and syslinux.cfg
serial=false

# size of the boot partition
boot_size=128M

# size of the file created for qemu VM
vm_size=4G

# default paths
root_dir=/mnt/xx
xx_bin=/home/xx/bin/xx

# path to the default initramfs file
initramfs_file='/home/xx/initramfs/build/initramfs.cpio.zst'

# type of the disk: 'device' (path to /dev/*) or 'file' (path to a regular file)
dev_type=

# path to the master boot record for the boot disk to use
mbr=

# for encrypted root, name of the /dev/mapper device and its full path
map_dev=xx_install_rootpart
part_enc=/dev/mapper/${map_dev}

# UUIDs for partitions to be created, either generated by the script or read
# from the sys config files
uuid_p1="$(uuidgen | sed 's|.*-.*-.*-.*-.\{4\}|00000000-0000-0000-0000-0000|')"
uuid_p2="$(uuidgen | sed 's|.*-.*-.*-.*-.\{4\}|00000000-0000-0000-0000-0000|')"
partuuid_p2="${uuid_p2}"

# first free loop device to use for dev_type 'file'
loop_dev=

# just a helper function defined early
function err_exit() {
	printf 'ERROR: %s\n' "${1}"
	exit 1
}

function usage() {
	echo 'usage: dev_install [ARGS]'
	echo
	echo ' -t, --target <path>  path to target device or file'
	echo ' -s, --set <path>     path to xx set file'
	echo ' -c, --config <path>  path to xx system config dir'
	echo ' -k, --kernel         (optional) kernel suffix'
	echo ' -S, --services       (optional) services to start on boot'
	echo ' -e, --encrypt        (optional) encrypt root partition'
	echo ' -i, --initramfs      (optional) include initramfs'
	echo ' -l, --lxc-net        (optional) set LXC_NET in rc.conf'
	echo ' -u, --uefi           (optional) create uefi parition'
	echo ' -r, --rs232          (optional) setup serial connection'
	echo ' -b, --boot-size      (optional) size of the boot partition e.g. 64M, 4G'
	echo ' -v, --vm-size        (optional) size of the VM disk e.g. 64M, 4G'

	exit 0
}



# parse args
# ==========

while [[ ${#} -gt 0 ]]; do
	key="${1}"
	case ${key} in
	-t|--target)
		dev="${2}"
		shift
		shift
		;;
	-s|--set)
		xx_set="${2}"
		shift
		shift
		;;
	-c|--config)
		cfg_dir="${2}"
		cfg_name="$(basename "${cfg_dir}")"
		cfg_arg="-c"
		shift
		shift
		;;
	-k|--kernel)
		kernel="${2}"
		shift
		shift
		;;
	-S|--services)
		services="${2}"
		shift
		shift
		;;
	-e|--encrypt)
		encrypt=true
		initramfs=true
		shift
		;;
	-i|--initramfs)
		initramfs=true
		shift
		;;
	-l|--lxc-net)
		lxc_net=true
		shift
		;;
	-u|--uefi)
		uefi=true
		shift
		;;
	-r|--rs232)
		serial=true
		shift
		;;
	-b|--boot-size)
		boot_size="${2}"
		shift
		shift
		;;
	-v|--vm-size)
		vm_size="${2}"
		shift
		shift
		;;
	-h|--help)
		usage
		;;
	*)
		err_exit "unknown option '${key}'"
		;;
	esac
done

[[ "${dev}" == /dev/* ]] && dev_type='device' || dev_type='file'

syslinux_dir="$(dirname "$(find /home/xx/prog/sys/syslinux/pkg/musl-* \
	/share/syslinux \
	/usr/share/syslinux \
	-name syslinux.com 2>/dev/null |
	sort |
	tail -n1)")"
mbr="${syslinux_dir}/gptmbr.bin"

[ ${uefi} == true ] && uuid_p1="0000-$(od -N2 -tx1 -An /dev/random | tr -d \ )"

if [ ${dev_type} == 'device' ]; then
	boot_part="${dev}1"
	root_part="${dev}2"
elif [ ${dev_type} == 'file' ]; then
	loop_dev="$(losetup --find)"
	boot_part="${loop_dev}p1"
	root_part="${loop_dev}p2"
fi



# tests and checks
# ================

[ -z "${dev}" ] && err_exit 'target device or file missing'
if [ ${dev_type} == 'device' ] && [ ! -b "${dev}" ]; then
	err_exit "target device '${dev}' doesn't exist or is not a block device"
fi

[ -z "${xx_set}" ] && err_exit 'xx set file missing'
[ ! -f "${xx_set}" ] && err_exit "xx set file '${xx_set}' doesn't exist"

[ -z "${cfg_dir}" ] && err_exit 'config dir missing'
[[ "${cfg_name}" =~ [^a-zA-Z0-9-_] ]] &&
	err_exit "name of the config dir must be in: alphanum '_' '-'"

[[ "${kernel}" =~ [^a-zA-Z0-9-_] ]] &&
	err_exit "name of the config dir must be in: alphanum '_' '-'"

[ -z "$(find /home/xx/prog/sys/linux/pkg -type f -name vmlinuz-${kernel})" ] &&
	err_exit "kernel vmlinuz-${kernel} wasn't built yet"

for s in ${services}; do
	p="/home/xx/prog/*/*/cfg/*/etc/init.d/${s}"
	[ -z "$(find /home/xx/prog -path "${p}")" ] &&
		err_exit "service '${s}' doesn't exist"
done
unset p s

if [ ${initramfs} == true ] && [ ! -f "${initramfs_file}" ]; then
	err_exit "${initramfs_file} must exist"
fi

if [ ${dev_type} == 'file' ] && [ ${uefi} == true ] ; then
	err_exit "uefi install is available only for disks in /dev"
fi

[[ "${boot_size}" =~ ^[0-9]{1,4}[MG]$ ]] || err_exit 'incorrect boot size'

[[ "${vm_size}" =~ ^[0-9]{1,4}[MG]$ ]] || err_exit 'incorrect VM size'
if [ ${dev_type} == 'device' ] && [ ${vm_size} != '4G' ]; then
	err_exit "VM size can't be specified for a device file"
fi

findmnt "${root_dir}" && err_exit "${root_dir} already mounted"
[ "${root_dir}" == '' ] && err_exit "root_dir is empty"
[ "${root_dir}" == '/' ] && err_exit "/ as root_dir not allowed"

[ ! -f "${mbr}" ] && err_exit "can't find gptmbr.bin file"

[ ${dev_type} == 'file' ] && [[ "${loop_dev}" != /dev/loop* ]] &&
	err_exit "loop device should like like '/dev/loop*', not '${loop_dev}'"



# define functions
# ================

function read_syslinux_cfg() {
	# fstab must also exist in sys config dir
	[ ! -f "${cfg_dir}/util-linux/all-latest/etc/fstab" ] &&
		err_exit 'no fstab in sys config dir'

	# kernel command line parameters
	local cmdline=
	cmdline="$(grep 'APPEND ' "${cfg_file}" | head -n1)"
	[ -z "${cmdline}" ] &&
		err_exit 'no APPEND line in existing syslinux.cfg'

	echo "${cmdline}" | grep -q cryptdev= && encrypt=true
	echo "${cmdline}" | grep -q bootdev= ||
		err_exit 'no bootdev in syslinux.cfg APPEND line'

	if [ -f "${cfg_dir}/syslinux/all-latest/boot/initramfs.cpio.zst" ]; then
		grep -q 'INITRD ' "${cfg_file}" && initramfs=true
	fi

	if [ ${encrypt} == true ]; then
		if ! echo "${cmdline}" | grep -q cryptdev= ; then
			err_exit 'no cryptdev in syslinux.cfg APPEND line'
		fi
		uuid_p2="$(echo "${cmdline}" | sed 's| |\n|g' |
			grep cryptdev= | cut -d'=' -f2)"

	elif [ ${encrypt} == false ] && [ ${initramfs} == false ]; then
		if ! echo "${cmdline}" | grep -q root=PARTUUID= ; then
			err_exit 'no root partuuid in syslinux.cfg APPEND line'
		fi
		partuuid_p2="$(echo "${cmdline}" | sed 's| |\n|g' |
			grep root=PARTUUID= | cut -d'=' -f3)"

	elif [ ${encrypt} == false ] && [ ${initramfs} == true ]; then
		if ! echo "${cmdline}" | grep -q root=UUID= ; then
			err_exit 'no root uuid in syslinux.cfg APPEND line'
		fi
		uuid_p2="$(echo "${cmdline}" | sed 's| |\n|g' |
			grep root=UUID= | cut -d'=' -f3)"
	fi

	uuid_p1="$(echo "${cmdline}" | sed 's| |\n|g' |
			grep bootdev= | cut -d'=' -f2)"
}

function read_fstab() {
	if [ ${encrypt} == false ] && [ ${initramfs} == false ]; then
		if ! cat "${cfg_file}" | tr '\t' ' ' | grep -q ' /boot '; then
			err_exit 'no /boot entry in fstab in sys config dir'
		fi

		uuid_p2="$(cat "${cfg_file}" | tr '\t' ' ' | grep ' / ' |
			cut -d' ' -f1 | cut -d'=' -f2)"
	fi

	# check if syslinux.cfg contains the same UUIDs, which are supposed to
	# be read from there in the previous function
	if ! grep -q "UUID=${uuid_p1}" "${cfg_file}"; then
		err_exit "boot UUID in fstab and syslinux.cfg don't match"
	fi

	if [ ${encrypt} == true ]; then
		if ! grep -q '/dev/mapper/root' "${cfg_file}"; then
			err_exit '/dev/mapper/root in fstab missing'
		fi
	fi

	echo -e '\n* values read from fstab and syslinux.cfg:'
	echo "encryption:           ${encrypt}"
	echo "initramfs:            ${initramfs}"
	echo "uuid_p1:              ${uuid_p1}"
	echo "uuid_p2:              ${uuid_p2}"
	echo "partuuid_p2:          ${partuuid_p2}"
}

function prepare_disk() {
	if [ ${dev_type} == 'device' ]; then
		sgdisk --zap-all "${dev}" &&
		dd if=/dev/zero of="${dev}" bs=1M count=256
	elif [ ${dev_type} == 'file' ]; then
		qemu-img create -f raw "${dev}" "${vm_size}"
	fi
	sgdisk -g "${dev}"
}

function create_partitions() {
	sgdisk --new "1:+1M:+${boot_size}" -u "1:${uuid_p1}" "${dev}"
	sgdisk --new 2::-0 -u "2:${partuuid_p2}" "${dev}"

	[ ${uefi} == false ] && sgdisk -t 1:ef02 "${dev}"
	[ ${uefi} == true ]  && sgdisk -t 1:ef00 "${dev}"
	sgdisk -t 2:8300 "${dev}"
	sgdisk --attributes 1:set:2 "${dev}"

	if [ ${dev_type} == 'file' ]; then
		losetup -Pf "${dev}"
		sleep 0.3
	fi

	# write mbr to the disk
	dd bs=440 conv=notrunc count=1 if="${mbr}" of="${dev}"
}

function create_filesystems() {
	# create boot partition fs
	if [ ${uefi} == false ]; then
		mkfs.ext4 -U "${uuid_p1}" -I 256 "${boot_part}"
		resize2fs -s "${boot_part}"
	else
		mkfs.fat -i "$(sed 's|-||' <<< "${uuid_p1}")" -F32 "${boot_part}"
	fi

	# create root partition fs
	if [ ${encrypt} == true ]; then
		cryptsetup -v \
			--type luks2 \
			--hash sha512 \
			--cipher aes-xts-plain64 \
			--key-size 512 \
			--pbkdf argon2id \
			--iter-time 5000 \
			--batch-mode \
			--uuid="${uuid_p2}" \
			luksFormat "${root_part}"
		echo 'Enter the password again to mount root...'
		cryptsetup luksOpen --allow-discards "${root_part}" ${map_dev}
		mkfs.ext4 -U "${uuid_p2}" "${part_enc}"
	else
		mkfs.ext4 -U "${uuid_p2}" "${root_part}"
	fi
}

function mount_partitions() {
	if [ ${encrypt} == true ]; then
		mount "${part_enc}" "${root_dir}"
	else
		mount "${root_part}" "${root_dir}"
	fi

	mkdir -p "${root_dir}/boot"
	mount "${boot_part}" "${root_dir}/boot"
}

function install_bootloader() {
	if [ ${uefi} == false ]; then
		mkdir -p "${root_dir}/boot/syslinux/modules"
		extlinux --install ${root_dir}/boot/syslinux/
		cp "${syslinux_dir}"/*.c32 \
			"${root_dir}/boot/syslinux/modules/"

	else
		mkdir -p "${root_dir}/boot/efi/boot/modules" \
			"${root_dir}/boot/syslinux/modules"
		umount "${root_dir}/boot"
		syslinux --directory syslinux --install "${boot_part}"
		mount "${boot_part}" "${root_dir}/boot"

		cp "${syslinux_dir}/efi64/syslinux.efi" \
			"${root_dir}/boot/efi/boot/bootx64.efi"
		cp "${syslinux_dir}/efi64/ldlinux.e64" \
			"${root_dir}/boot/efi/boot/"
		cp "${syslinux_dir}"/efi64/*.c32 \
			"${root_dir}/boot/efi/boot/modules/"
		cp "${syslinux_dir}"/*.c32 \
			"${root_dir}/boot/syslinux/modules/"
		cp "${root_dir}/boot/syslinux/syslinux.cfg" \
			"${root_dir}/boot/efi/boot/"
	fi
	sync "${boot_part}"
}

function set_syslinux_cfg() {
	if [ ${encrypt} == true ]; then
		r=/dev/mapper/root
		sed -i "s|root=/dev/sda2|cryptdev=${uuid_p2} root=${r}|g" \
			"${syscfg_file}"

	elif [ ${initramfs} == false ]; then
		sed -i "s|root=/dev/sda2|root=PARTUUID=${partuuid_p2}|g" \
			"${syscfg_file}"
		sed -i -e 's| ro$| rw|g' -e 's| ro | rw |g' "${syscfg_file}"

	elif [ ${initramfs} == true ]; then
		sed -i "s|root=/dev/sda2|root=UUID=${uuid_p2}|g" \
			"${syscfg_file}"
	fi

	if [ ${initramfs} == true ]; then
		sed -i -z 's|APPEND |INITRD /initramfs.cpio.zst\n\t&|' \
			"${syscfg_file}"
		cp "${initramfs_file}" "${root_dir}/boot/"
	fi

	if [ ${serial} == true ]; then
		local args='console=tty0 console=ttyS0,115200'
		sed -i "/APPEND/ s|$| ${args}|" "${syscfg_file}"
		sed -i "s|MENU LABEL memtest|&\n\tAPPEND ${args}|" \
			"${syscfg_file}"
	fi

	sed -i "/APPEND/ s|$| bootdev=${uuid_p1}|g" "${syscfg_file}"
	sed -i "s|vmlinuz-generic|vmlinuz-${kernel}|g" "${syscfg_file}"

	local efisyscfg_file="${root_dir}/boot/efi/boot/syslinux.cfg"
	local eficfg_dir="${cfg_dir}/syslinux/all-latest/boot/efi/boot/"

	if [ ${uefi} == true ]; then
		mkdir -p "$(dirname "${efisyscfg_file}")"
		cp "${syscfg_file}" "${efisyscfg_file}"
		sed -i 's|/syslinux/modules|/efi/boot/modules|g' \
			"${efisyscfg_file}"
	fi

	# save newly created files

	mkdir -p "$(dirname "${cfg_file}")"
	cp "${syscfg_file}" "${cfg_file}"

	if [ ${initramfs} == true ]; then
		cp ${initramfs_file} "${cfg_dir}/syslinux/all-latest/boot/"
	fi

	if [ ${uefi} == true ]; then
		mkdir -p "${eficfg_dir}"
		cp "${efisyscfg_file}" "${eficfg_dir}"
	fi
}

function set_fstab() {
	sed -i "s|/dev/sda1|UUID=${uuid_p1}|g" "${syscfg_file}"

	if [ ${encrypt} == true ]; then
		sed -i 's|/dev/sda2|/dev/mapper/root|g' "${syscfg_file}"
	else
		sed -i "s|/dev/sda2|UUID=${uuid_p2}|g" "${syscfg_file}"
	fi

	if [ ${uefi} == true ]; then
		sed -i "/\t\/boot\t/ s|ext4|vfat|g" "${syscfg_file}"
	fi

	# save newly created file
	mkdir -p "$(dirname "${cfg_file}")"
	cp "${syscfg_file}" "${cfg_file}"
}

function set_rc_conf() {
	if [ "${cfg_name}" != '' ]; then
		sed -i "s|^HOSTNAME=.*|HOSTNAME=${cfg_name}|g" "${syscfg_file}"
	fi

	if [ "${lxc_net}" == true ]; then
		sed -i "s|LXC_NET=.*|LXC_NET='true'|g" "${syscfg_file}"
	fi

	sed -i "s|SERVICES=.*|SERVICES='${services}'|g" "${syscfg_file}"

	# save newly created file
	mkdir -p "$(dirname "${cfg_file}")"
	cp "${syscfg_file}" "${cfg_file}"
}

function set_boot_conf() {
	if [ ${encrypt} == true ]; then
		sed -i 's|ENC=false|ENC=true|g' "${syscfg_file}"
	fi

	if [ ${serial} == true ]; then
		sed -i 's|SERIAL=false|SERIAL=true|g' "${syscfg_file}"
	fi

	# save newly created file
	mkdir -p "$(dirname "${cfg_file}")"
	cp "${syscfg_file}" "${cfg_file}"
}

function set_inittab() {
	local line='ttyS0::respawn:/bin/busybox getty 115200 ttyS0 vt100'

	if [ ${serial} == true ]; then
		sed -i "s|^::ctrlaltdel:|${line}\n\n&|" "${syscfg_file}"

		# save newly created file
		mkdir -p "$(dirname "${cfg_file}")"
		cp "${syscfg_file}" "${cfg_file}"
	fi
}

function unmount() {
	umount "${root_dir}/boot/"
	umount "${root_dir}"

	[ ${encrypt} == true ] && cryptsetup luksClose ${map_dev}
	[ ${dev_type} == 'file' ] && losetup -d "${loop_dev}"

	find /home/xx -type f -name '*.log' -exec chown xx: {} \+
	chown xx:xx /tmp/xx /tmp/xx/config /mnt/xx
}



# confirmation
# ============

echo -e "\ntarget device/file:   ${dev}"
echo "xx set:               ${xx_set}"
echo "system config dir:    ${cfg_dir}"
echo "encryption:           ${encrypt}"
echo "initramfs:            ${initramfs}"
echo "lxc networking:       ${lxc_net}"

echo -e "\nThis ${dev_type} is going to be wiped:"
echo -e "${dev}\n"
[ -b "${dev}" ] && lsblk -o NAME,SIZE,FSUSED,TYPE,FSTYPE,MOUNTPOINT "${dev}"
printf "\nPress 'Ctrl+c' to abort or 'Enter' to continue..."
read



# read existing config files
# ==========================

# syslinux.cfg

cfg_file="${cfg_dir}/syslinux/all-latest/boot/syslinux/syslinux.cfg"
if [ -f "${cfg_file}" ]; then
	read_syslinux_cfg
fi

# fstab

cfg_file="${cfg_dir}/util-linux/all-latest/etc/fstab"
if [ -f "${cfg_file}" ]; then
	read_fstab
fi

# xx set

if [[ -f "${cfg_dir}"/*.xx ]]; then
	read_fstab
fi

unset cfg_file

# ssh

ssh_host_file="${cfg_dir}/openssh/all-latest/etc/ssh/ssh_host_ed25519_key"
if [[ ! -f "${ssh_host_file}" ]]; then
  mkdir -p "$(dirname "${ssh_host_file}")"
  ssh-keygen -t ed25519 -P '' -f "${ssh_host_file}"
fi

unset ssh_host_file


# actions
# =======

echo -e '\n* preparing disk/file...'
prepare_disk

echo -e '\n* creating partitions...'
create_partitions

echo -e '\n* creating filesystems...'
create_filesystems

echo -e '\n* mounting partitions...'
mount_partitions

echo -e '\n* installing...'
"${xx_bin}" install "${cfg_arg}" "${cfg_dir}" -r "${root_dir}" -t "${xx_set}"

echo -e '\n* syncing disk...'
sync "${boot_part}" "${root_part}"

echo -e '\n* installing bootloader...'
install_bootloader



# create config files
# ===================

# syslinux.cfg

cfg_file="${cfg_dir}/syslinux/all-latest/boot/syslinux/syslinux.cfg"
syscfg_file="${root_dir}/boot/syslinux/syslinux.cfg"
if [ ! -f "${cfg_file}" ]; then
	set_syslinux_cfg
fi

# fstab

cfg_file="${cfg_dir}/util-linux/all-latest/etc/fstab"
syscfg_file="${root_dir}/etc/fstab"
if [ ! -f "${cfg_file}" ]; then
	set_fstab
fi

# rc.conf

cfg_file="${cfg_dir}/busybox/sysinit-latest/etc/rc.conf"
syscfg_file="${root_dir}/etc/rc.conf"
if [ ! -f "${cfg_file}" ]; then
	set_rc_conf
fi

# boot.conf

cfg_file="${cfg_dir}/syslinux/all-latest/boot/boot.conf"
syscfg_file="${root_dir}/boot/boot.conf"
if [ ! -f "${cfg_file}" ]; then
	set_boot_conf
fi

# inittab

cfg_file="${cfg_dir}/busybox/sysinit-latest/etc/inittab"
syscfg_file="${root_dir}/etc/inittab"
if [ ! -f "${cfg_file}" ]; then
	set_inittab
fi

unset cfg_file syscfg_file

# xx set

cp -n "${xx_set}" "${cfg_dir}"



# finish
# ======

echo -e '\n* unmounting...'
unmount

echo -e '\n* done'

if [ ${uefi} == true ]; then
	echo "don't forget to manually add uefi entries, e.g.:"
	echo 'efibootmgr -v -c -d /dev/sda -p 1 -l \\efi\\boot\\bootx64.efi -L "xx syslinux"'
fi

